### 孤儿进程和僵尸进程区别

**僵尸进程**

**僵尸进程**是已经**终止**（执行完毕或被杀死）但其父进程尚未**收集**（`wait()` 或 `waitpid()` 系统调用）其退出状态的进程

- **产生原因**：当一个子进程终止时，它会向操作系统发送一个信号，表示自己已完成任务。操作系统会释放该进程几乎所有的资源，包括内存和文件描述符。然而，它的进程描述符（PCB，Process Control Block）仍然保留在内存中，以便父进程能够读取它的退出状态（例如，是否成功执行、退出码是多少）。如果父进程没有及时调用 `wait()` 或 `waitpid()` 来获取这些信息并释放子进程的 PCB，子进程就会一直处于“僵尸”状态
- **特点**：
  - 它**不占用**内存空间
  - 它**会占用**一个 PID，因为 PCB 还没有被回收
  - 由于 PID 是有限的，大量的僵尸进程可能会导致系统没有可用的 PID，从而无法创建新的进程
- **如何识别**：在 `ps` 或 `top` 命令的输出中，僵尸进程的状态通常显示为 `<defunct>` 或 `Z`
- **处理方法**：唯一能清理僵尸进程的方法是**杀死它的父进程**。当父进程被杀死后，这个僵尸进程就会变成一个孤儿进程，并被 `init` 进程（PID 1）收养，`init` 进程会负责清理它。

**孤儿进程**

**孤儿进程**是指**正在运行**但其父进程已经**终止**的进程

- **产生原因**：当父进程在子进程之前退出，子进程就成了“孤儿”
- **特点**：
  - 它**仍然在运行**，只是失去了它的原始父进程
  - 它**不会**成为系统的负担，因为它会自动被操作系统中最特殊的进程——`init` 进程（PID 1）收养
- **如何识别**：在 `ps` 命令的输出中，你可以看到它的父进程 ID（PPID）变成了 `1`
- **处理方法**：孤儿进程会被 `init` 进程**收养**。`init` 进程会像对待自己的子进程一样，在它最终终止时调用 `wait()` 来收集其退出状态，从而防止它变成一个僵尸进程

| 特性     | 僵尸进程（Zombie Process）              | 孤儿进程（Orphan Process）                 |
| -------- | --------------------------------------- | ------------------------------------------ |
| 状态     | 已终止，但其进程描述符未被父进程回收。  | 正在运行，但其父进程已终止。               |
| 产生原因 | 父进程没有调用 wait() 或 waitpid()。    | 父进程在子进程之前退出。                   |
| 系统影响 | 占用 PID，大量存在会导致 PID 资源耗尽。 | 通常无害，会被 init 进程收养。             |
| 处理方式 | 杀死其父进程。                          | 由 init 进程自动收养并管理，无需人工干预。 |
| ps 状态  | Z 或 `<defunct>`                        | 运行中，但其 PPID（父进程 ID）为 1。       |
